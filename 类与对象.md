# 类与对象

c++面向对象的三大特性为：封装、继承、多态

c++认为万事万物皆为对象，对象上有其属性和行为

### 1. 封装

1. 意义：将属性和行为作为一个整体，表现生活中的事物

   ​            将属性与行为加以权限控制

2. 类的创建方法：

   类名，访问权限，对象（变量），行为（方法）

3. 访问：

   与结构体类似，用点运算符“ . ”进行访问

4. 给对象赋值：

   先实例化对象

   可以直接用“ . ”访问对象，实现赋值操作

   可以在类中创建赋值的函数，用类中函数传递参数的方式访问

5. 相关术语：

   类中的属性和行为，我们统一称为成员

   属性也叫成员属性，成员变量

   行为也叫成员函数，成员方法

6. 访问权限：

   目的： 类在设计时，可以把属性和行为放在不同的权限下，加以控制

   成员的访问权限有三种：

   - public 			类内外可以访问
   - protected	  只有类内可以访问     儿子可以访问父亲中的保护内容
   - private			只有类内可以访问    儿子不可以访问父亲中的私有内容

7. struct和class的区别

   默认的访问权限不同 struct为public，class为private

8. 将成员属性设置为私有

   优点1： 将所有成员属性设置为私有，可以自己控制读写（添加一些public的接口）

   优点2： 对于写权限，我们可以检测数据的有效性

9. 分文件编写类

   在一个项目下创建若干个关于类的分文件，将类的声明写在头文件中，类的实现写在源文件中，

   主程序中调用头文件即可。

### 2. 对象的初始化和清理

1. 构造函数和析构函数

   - 这两个函数会被编译器分别在创建、销毁对象的时候自动调用。

   - 若我们不写这两个函数，编译器会自动提供这两个空实现函数。

   - 语法：

     构造函数： 类名（）{}

     没有返回值也不写void，函数名与类名相同，可以有参数，可以发生重载，创建对象时自动调用

     析构函数： ~类名 （）{}

     没有返回值也不写void, 不可以有参数，不可以发生重载，对象销毁前自动调用

2. 构造函数的分类及调用

   分类：

   - 按照参数：无参构造（默认构造），有参构造
   - 按照构造类型： 普通构造，拷贝构造
     - 拷贝构造的参数写为const 类名& 形参名（为什么要这么写？？）

   调用方法：

   - 括号法
   - 显示法
   - 隐式转换法

   注意事项：

   1. 调用默认构造函数时，不要加()，因为编译器会认为是一个函数的声明，不会创建对象
   2. 不要利用拷贝构造函数初始化匿名对象，编译器会认为Person (p3) = Person p3,重定义

3. 拷贝构造函数的调用时机
   - 使用一个已经创建完毕的对象来初始化一个新的对象
   - 值传递的方式给参数传值（编译器会在函数中临时拷贝一个对象，将其作为参数）
   - 以值的方式返回局部对象（根据返回的值创建一个新的对象（生命周期如何？？），返回该对象）

4. 构造函数的调用规则

   默认情况下，编译器至少给一个类自动添加三个函数

   默认构造函数（无参，函数体为空）

   默认析构函数（无参，函数体为空）

   默认拷贝构造函数（值拷贝）

   - 如果用户定义有参构造函数，编译器不再提供无参构造函数，但会提供拷贝构造函数
   - 如果用户自定义拷贝构造函数，编译器不再提供其他构造函数

5. 深拷贝与浅拷贝

   深拷贝：在堆区创建新的内存空间，（用指针的方式）联系堆区的内存

   浅拷贝：默认拷贝函数那样，只是复制了对象中的全部数据

   释放内存规范写法

   ~~~ c++
   ~Person()
   	{
   		if (m_height != NULL)
   		{
   			delete m_height;		//把这个指针指向的堆区的内存释放掉（非指针本身）
   			m_height = NULL;		//把这个指针置空，防止野指针的出现
   		}
   		cout << "Person析构函数的调用" << endl;
   	}
   ~~~

   在堆区开辟内存空间，并让类中的指针指向这块内存。此时如果进行简单的浅拷贝，那么指针指向的地址也被原封不动地拷贝了过来。在利用析构释放内存时，会出现这块内存被重复释放的问题。因此我们需要自己编写拷贝构造函数来进行深拷贝。

   ~~~c++
   Person(const Person& p)
   	{
   		m_age = p.m_age;
   		m_height = new int(*p.m_height);
   	}
   ~~~

   ~~~c++
   Person(int a, int h): m_age(a), m_height(new int(h)){}
   ~~~

   6. 初始化列表

   7. 类嵌套类

      构造时先构造内层，在构造外层

      析构时先析构外层，再析构内存

   8. 静态成员

      所有对象共享同一份数据

      在编译阶段分配内存

      静态成员对象类内声明，类外初始化（否则报错：无法解析的外部指令）

      语法：(class A)  

      类内：` static int m_a `;

      类外：`int A::m_a = 100`;

      静态成员函数创建：

      `static 返回值类型 函数名（）`

      访问：

      1. 可以创建一个类，在用点（“ . ”）运算符访问
      2. 对于静态成员变量（public），可以用`类 :: 成员`进行访问
      3. 静态成员函数只能访问静态成员变量

      静态成员（对象、函数）不属于某个对象，也有访问权限（public,protected,private）

      初始化操作不是访问，因为private权限也可以初始化

### 3. c++对象模型和this指针

1. 类成员的空间分配

   只有非静态成员变量才属于类的对象上

   类为空时（或没有非静态成员变量）占用一个内存空间（为了区分空对象占内存的位置），

   其他时候为静态成员变量所占内存之和

2. this指针

   指向被调用的成员函数所属的对象

   this指针是隐含在每个非静态成员函数内的一种指针

   不需要定义

   用途：

   - 当形参与成员函数同名时，可以用this指针区分（不规范）。但是用初始化列表时，编译器可以区分成员变量和形参。

   - 在类的非静态成员函数中返回对象本身（return *this）

     ~~~c++
      Person& addAge(Person a)	//只返回Person时，相当于返回了临时创建出来的拷贝的对象
     	 {
     		 age += a.age;
     		 return *this;	//返回引用即不拷贝新的对象，直接返回该类
     	 }
     ~~~

     *要实现迭代操作时，需要返回这个类所属的空间，因此要返回引用。



3. 空指针访问对象

   任何指针（空指针，野指针）都可以访问类的静态成员。一定不能访问非静态成员变量。

   如果访问非静态成员函数时，该函数没有调用非静态成员变量，则可以访问。

   也就是说，类类型指针只是不能访问存储到类上的内存空间（即非静态成员变量）

   为了提高空指针访问成员函数的代码的健壮性，可以加一个判断。this指针为空，则返回。

4. const修饰成员函数

   常函数：

   - 在后面加const修饰的成员函数内不可以修改非静态成员变量的属性
   - 本质：函数内创建的this指针从指针常量变成了const xxx* const pointer
   - 成员属性声明时加关键字mutable后，在常函数中依然可以修改 

   常对象：

   - 声明对象前加const修饰
   - 只能调用常函数（尽管其他函数没有访问成员变量）

   > static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。

### 4. 友元

- 目的：有些私有属性，也想让类外的某些函数或者类进行访问

1. 全局函数做友元

   语法：在类中写一行函数声明，前面加上friend

   例子：`friend void visit (Building& p);`

   注意：外层全局函数做友元时，尽管向内层函数传递某个对象的地址，外层函数也没有向内层嵌套的函数传			递友元的权限也就是说，友元的权限只作用于当前函数下。

2. 类做友元

   语法：在class A中加一行friend class B，表示允许B访问A （允许外类访问本类中所有对象）

   其他在黑马教学案例中的收获

​        成员函数，类可以先只写声明，再写实现。这类似于程序分文件编写。

​		这样可以让我们着眼于整体，将整体与细节分开。

3. 成员函数做友元

   语法：在类中写一行成员函数的声明（要用域"::"运算符）

   例子：`friend void Building::visit(Building* p)`

   说明：是类做友元的权限的收缩，其他没有声明的成员函数没有访问的权限

### 5. 运算符重载

- 概念：对已有的运算符重新进行定义，拓宽其功能，定义新的运算
- 说明：执行新定义运算的运算符必须是原来已经存在的
- 注意：对于内置的数据类型的表达式的运算符是不可能改变的，不要滥用运算符重载

1. 加号运算符重载

   实现同类或不同类的对象的某些加法

2. 左移运算符重载

   输出自定义数据类型

   注意：

   -  cout是ostream类下的一个对象，要实现迭代输出，要返回ostream类的cout对象(引用)
   -  只能在全局函数中实现，并必须传入ostream类下的cout对象(引用)，以及自定义数据类型的对象

   -  由于cout这个对象只有一个，因此要用引用的方式传进来

3. 递增(递减)运算符重载

   以递增为例

   前置递增：

   内置数据类型有迭代操作，即++(++a)，因此我们需要采用引用的方式返回自身(否则发生值拷贝)

   ~~~c++
   Point::Point& operator++()
   {
       m_x++;
       m_y++;
       return *this;
   }
   ~~~

   后置递增：

   内置的数据类型没有迭代操作，即(a++)++，因此我们只要返回值即可。

   设计思路：先拷贝一份值，再让内部数据递增，然后返回拷贝的值（原值）

   注意：编译器通过int占位参数来判定后置递增

   `Point::Point operator++(int){}`

4. 赋值运算符重载

   编译器至少给一个类添加4个函数。

   前三个已经记过，这里只记第四个：

   operator=, 对属性进行拷贝。

   如果类中有属性指向堆区，赋值操作时也会出现深浅拷贝的问题。因此，提供深拷贝，即赋值时都开辟次内存，把指针指向这块内存

   由于赋值号也有嵌套操作，因此要以引用的方式返回自身（赋值运算返回左值）

5. 关系运算符

6. 调用函数运算符

   - 函数调用运算符()也可以重载
   - 由于重载后使用方式非常像函数调用，因此被称为仿函数
   - 仿函数没有固定的写法，非常灵活

   其他：

   创建匿名对象来调用仿函数，可以免去实例化对象的操作。

   例子：

   ~~~c++
   void MyPoint::operator()(string t)
   {
   	cout << t << endl;
   }
   int main()
   {
       MyPoint mypoint;
   	mypoint("sdfsad");
   	MyPoint()("sdfsdfsdfasdf");	
   }
   ~~~

   

### 6. 继承

1. 基本语法：class A: 继承方式 B

   说明：A为子类（派生类），B为父类（基类）

2. 继承方式：public，protected，private

3. 继承中的对象模型

   父类中所有非静态成员属性都会被子类继承下去

   私有成员属性被继承下去了，但是被编译器隐藏了，访问不到

4. 继承中构造和析构的顺序

   先构造父类再构造子类，析构顺序与构造相反

5. 同名成员的访问

   1. 子类对象可以直接访问子类中的同名成员
   2. 子类对象加作用域可以访问到父类同名成员
      - 举例：`s.Based::m_a`,`s.Based::m_b()`

   3. 子类和父类拥有同名成员函数，子类会隐藏父类的同名成员函数（无法重载类父的函数），加作用域可访问到父类同名函数

6. 同名静态成员的访问

   1. 用对象访问时完全满足第五点中的三条

   2. 用类名访问

      可以直接用Son::m_a,Based::m_a直接访问

      强调子类继承的父类对象时，可用`Son::Base::m_a`

      第一个::表示通过类名的方式访问，第二个::表示访问父类作用域下

7. 多继承

   语法：class Son: 继承方式 B1，继承方式 B2...

   注意：

   - 当父类中出现同名成员时，需要加作用域区分
   - 一般不提倡用

