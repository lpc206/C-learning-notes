# 内存、引用、函数高级



### 1.内存分区模型  

程序执行时，将内存大方向划分为**4个区域**

- 代码区： 存放函数体的二进制代码，由操作系统进行管理
- 全局区： 存放静态变量及全局变量，常量
- 栈区： 由编译器自动分配和释放，存放函数的参数值，局部变量等
- 堆区：程序员分配和释放，若不释放，程序结束时由操作系统释放

**意义：**赋予不同的生命周期，灵活编程

1. 程序运行前

   **代码区：**

   存放CPU机器指令

   特点：共享，只读

   **全局区：**

   存放全局变量，静态变量，字符串常量，const修饰全局变量

   程序结束后由操作系统释放

2. 程序运行后

   __栈区：__

   其中的数据由编译器管理和释放，存放函数的参数值，局部变量等

   注意：不要返回局部变量的地址（栈区的数据在函数执行完后自动释放）

   ~~~c++
   int* func()
   { 
   	int a = 19;
   	return &a;
   }
   int main()
   {
       int* p = func();
       cout << *p << endl;		//第一次能打印正确的数字是因为编译器做了保留
       cout << *p << endl;		//非法操作
   }
   ~~~

   

   **堆区：**

   由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

   开辟时利用关键字new，释放时利用关键字delete

   ~~~ c++
   new int(10);		//开辟含有int10的空间，并返回int10所在的地址
   int* func()
   {
       int*p = new int(10);
       return p;
   }
   int* func2()
   {
       int *p = new int[10];	//在堆区创建一个数组
       return p;
   }
   int main()
   {
       int* p = func();
       cout << *p;
       delete p;		//释放
       cout << *p;		//报错
       int* arr = func2();
       for (int i = 0; i < 10; i++)
           arr[i] = i*i;
       for (int i = 0; i < 10; i++)
           cout << arr[i] << endl;
       delete[] arr;	//释放数组delete后面需要添加[]
   }
   ~~~

 ### 2. 引用

1. 概述

   引用： 给变量起别名

   语法： 数据类型 &别名 = 原名

   注意： 别名与原名访问同一块地址，是等价的

   注意事项： 引用必须初始化，初始化后不能改变。与取地址操作区分

2. 引用做函数参数

   作用：函数传递参数时，可以利用引用的技术让形参修饰实参

   优点：可以简化指针修改实参

3. 引用做函数的返回值

   注意：不要返回局部变量的引用

   意义：如果函数做左值，那么必须返回引用

   ~~~c++
int& test()		//返回为int型变量的引用
   {
    static int a = 20;	//用静态变量来增长局部变量的生命周期
       return a;
   }
   int main()
   {
       int& ref = test02();
       cout << ref;
       test02() = 1000;	//函数做左值
       cout << ref;		//输出1000
   }
   ~~~

4. 引用的本质

   引用本质是一个指针常量，指向不能修改，即引用初始化之后不能修改引用的对象

   编译器发现调用引用时，会自动解引用，转化为指向的值

5. 常量引用

   使用场景： 通常用来修饰形参，防止误操作

   ~~~c++
   int& ref = 10；		//错误，必须引用一个合法的内存空间
   const int& ref = 10；	//这样就可以了，实际上是int temp = 10; const int& ref = 							//temp两行的合并，ref不可修改，相当于常量;
   void show(const int& v)	//只是打印v的值，不希望v被误操作改动
   {				//由于引用本质是一个会自动解引用的指针常量，再加上const后变为const int* coust p，是一个常量
       //v++;	错误，加上const后，v的值不能改
       cout << v << endl;
   }
   ~~~

   总结一下，const修饰指针**前值后指**（限定）

### 3. 函数高级



1. 函数的默认参数

   语法

   ~~~ c++
   int func(int a = 10, int b = 12, int c = 0){}
   ~~~

   注意事项：

   - 如果有自己传入的数据，就用自己的数据，否则用默认值
   - 如果某个位置已经有了默认参数，那么从这个位置之后，从左向右都必须有默认值
   - 函数声明与函数定义中默认值设定加起来只能有一次

2. 函数的占位参数

   语法： 返回值类型 函数名 （数据类型） {}

   占位参数也可以设置默认值

3. 函数重载

   作用：函数名可以相同， 提高复用性

   满足条件: 同一作用域，函数名称相同，函数的参数类型不同或者个数不同或者顺序不同。

   注意： 返回值不能作为函数重载的条件

   注意事项：

   1. 引用作为函数重载的条件

      ~~~C++
      void func(int& a){}
      void func(const int& a){}	//视为两种数据类型
      int main()
      {
          int a = 10;
          func (a);	//调用第一个，a是可以读写的变量
          func (10);	//调用第二个，因为第一个没给地址，语法不对，第二个是常量引用
      }
      ~~~

   2. 函数重载时尽量不要写默认参数，防止二义性

      例如：

      ~~~c++
      void func (int a, int b = 10){}
      void func (int a){}
      int main()
      {
          func (10);	//报错，因为不是一一对应
      }
      ~~~

      

      

   

















